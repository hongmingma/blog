---
layout: post
title: BIO与NIO
category: 并发编程
---
[参考：Java NIO 系列教程  ,这篇文章翻译的还是有点绕，但是基本说清楚了NIO](http://www.iteye.com/magazines/132-Java-NIO)

####	1.IO的 理解
 按照《Unix网络编程》的划分，IO模型可以分为：阻塞IO、非阻塞IO、IO复用、信号驱动IO和异步IO，按照POSIX标准来划分只分为两类:同步IO和异步IO。
 
 >>如何区分呢？首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，
 那么就是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。
 阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。
  

####	2. BIO与NIO的区别
* 面向流与面向缓冲

>> Java NIO和BIO之间第一个最大的区别是，BIO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。
此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，
需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖
缓冲区里尚未处理的数据。 

* 阻塞与非阻塞IO
 
>> Java BIO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了，
早期版本的TOMCAT的典型实现方式,简单理解就是一个连接一个线程。
Java NIO的非阻塞模式，简单理解就是一个请求一个线程，处理请求的线程是非阻塞的，发起IO请求的操作并没有把处理IO请求的线程一直阻塞在那里。
处理请求的线程从缓冲区读取或写入流，做完部分工作可以继续做其他的事情，并非一直阻塞在这里。
但是持有选择器（Selectors）用来监听通道上的流的线程还是阻塞的(参考IO理解的描述，不要搞混概念)。
 
* 选择器（Selectors）

>> Java NIO的选择器允许一个单独的线程来监视多个通道，你可以注册多个通道到一个选择器，然后使用一个单独的线程来监听多通道上的流管理多通道，如打开连接，
监听是否有数据到达。 



  



 