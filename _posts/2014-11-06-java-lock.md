---
layout: post
title: java并发场景保证数据一致性的方法
category: [并发编程]
---
[参考：深入JVM锁机制 synchronized ](http://blog.csdn.net/chen77716/article/details/6618779)

[参考：深入JVM锁机制 Lock ](http://blog.csdn.net/chen77716/article/details/6618779)

[参考：原子操作实现原理 ](http://ifeve.com/atomic-operation/)

[参考：正确使用 Volatile 变量](http://www.ibm.com/developerworks/cn/java/j-jtp06197.html)







####1.	 synchronized

synrhronized关键字简洁、清晰、语义明确，因此即使有了Lock接口，使用的还是非常广泛，现在性能已经做了很多改进。其应用层的语义是可以把任何一个非null对象作为"锁".

* 当synchronized作用在方法上时，锁住的便是对象实例（this）
* 当作用在静态方法时锁住的便是对象对应的Class实例，因为Class数据存在于永久带，因此静态方法锁相当于该类的一个全局锁
* 当synchronized作用于某一个对象实例时，锁住的便是对应的代码块。

实现原理

>> synrhronized 是非公平锁的一种，稍微牺牲了公平性，但获得了高吞吐量
synchronized的底层也是一个基于CAS操作的等待队列，但JVM实现的更精细，基本思路是自旋（通过CAS实现，避免线程频繁的进行状态切换）后未争抢到锁再阻塞，
把等待队列分为ContentionList和EntryList，目的是为了降低线程的出列速度，也实现了偏向锁，从数据结构来说与ReentrantLock设计没有本质区别。
但synchronized还实现了自旋锁，并针对不同的系统和硬件体系进行了优化，而Lock则完全依靠系统阻塞挂起等待线程。

####2.	 显示的使用lock
在java.util.concurrent.locks包中有很多Lock的实现类，常用的有ReentrantLock、ReadWriteLock（实现类ReentrantReadWriteLock），
其实现都依赖java.util.concurrent.AbstractQueuedSynchronizer类，实现思路都大同小异，主要是使用灵活，扩展性好，自己控制枷锁，解锁，锁的使用对代码是透明的。

####3.	 原子操作

通过CAS实现自旋锁（与hibernate乐观锁实现原理类似），避免线程进行频繁的状态切换，实现一些计数器类的操作很方便。

CAS实现原理

>>CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。

缺点如下

*	ABA问题

>> 因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，
那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。
在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。

* 循环时间长开销大。

>>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

*	只能保证一个共享变量的原子操作。

>>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，
这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，
然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。

>>

####4.	 声明volatile

通过lock前缀声言，锁总线或锁缓存，没有自旋的过程，系统开销较小，比较轻量，但是适合的场景也比较少。
Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。
Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。
因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类。
出于简易性或可伸缩性的考虑，您可能倾向于使用 volatile 变量而不是锁。此外，volatile 变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。
在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。

正确使用 volatile 变量的条件
您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：

>> 对变量的写操作不依赖于当前值。

>> 该变量没有包含在具有其他变量的不变式中。

* 总线锁

>>使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。

* 缓存锁 

>> 所谓“缓存锁定”就是如果缓存在处理器缓存行中***内存区域在LOCK操作期间被锁定***，当它执行锁操作回写内存时，
处理器不在总线上声言LOCK＃信号，而是***修改内部的内存地址***，并允许它的缓存一致性机制来保证操作的原子性，
因为***缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据***，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效.
如当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。

####5.	 数据隔离

这里只是一种思想，和上面靠锁实现的应用场景不同，如

>> 用threadlocal 可以把某个线程关心的数据自己带着走，避免别人可修改，自然就是安全的了，避免争抢，如多线程场景的一些session实现

>> 把争抢数据粒度细化，尽量降低多个线程同时抢一把锁的几率，如concurrenthashmap 分段锁。


  
  


  



 