---
layout: post
title:  java thread lifecycle
category: [并发编程]
---



![Alt text](/images/thread.jpg)

####1.	状态切换过程中几个方法注意事项

* join() 等待此线程死亡后再继续，可使异步线程变为同步线程

* interrupt()：中断线程，被中断线程会抛InterruptedException

* wait()  属于对象的方法，必须在拥有锁的情况下调用，释放锁并进入等待队列。

* notify()&notifyAll()   属于对象的方法，必须在拥有锁的情况下调用，notify()释放锁并发通知wait状态等待队列中的一个线程锁可以使用了，这个线程进入进入新等待队列，抢到锁就占有CPU继续执行程序。
notifyAll() 通知所有处于wait状态等待队列中的线程锁可以使用了，能否抢到锁看能力，二者使用区别不大。


* sleep() 是线程类的静态方法，让当前正在执行的线程休眠，和锁没有关系。

* yield() 暂停当前正在执行的线程，并执行其他线程。

####2.	sleep和yield区别：

* sleep()方法会给其他线程运行的机会，而不考虑其他线程的优先级，因此会给较低线程一个运行的机会
当线程执行了sleep(long millis)方法后，将转到阻塞状态，参数millis指定睡眠时间。

* yield()方法只会给相同优先级或者更高优先级的线程一个运行的机会。 
当线程执行了yield()方法后，将转到就绪状态。 

* sleep()方法声明抛出InterruptedException异常，而yield()方法没有声明抛出任何异常 

* sleep()方法比yield()方法具有更好的移植性 


####3.	阻塞状态分为三种情况： 

* 位于对象等待池中的阻塞状态

>>当线程运行时，如果执行了某个对象的wait()方法，java虚拟机就回把线程放到这个对象的等待池中 

* 位于对象锁中的阻塞状态

>>当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他的线程占用，JVM就会把这个线程放到这个对象的琐池中。 

* 其它的阻塞状态

>>当前线程执行了sleep()方法，或者调用了其它线程的join()方法，或者发出了I/O请求时，就会进入这个状态中。

  



 